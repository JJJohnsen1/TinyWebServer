半同步/半反应堆线程池
===============
使用一个工作队列完全解除了主线程和工作线程的耦合关系：主线程往工作队列中插入任务，工作线程通过竞争来取得任务并执行它。
> * 同步I/O模拟proactor模式
> * 半同步/半反应堆
> * 线程池

## 事件处理模式：
1. reactor模式中，主线程(I/O处理单元)只负责监听文件描述符上是否有事件发生，有的话立即通知工作线程(逻辑单元 )，读写数据、接受新连接及处理客户请求均在工作线程中完成。通常由同步I/O实现。
2. proactor模式中，主线程和内核负责处理读写数据、接受新连接等I/O操作，工作线程仅负责业务逻辑，如处理客户请求。通常由异步I/O实现。

## 半同步/半反应堆
半同步/半异步（Half-Sync/Half-Async） 的核心思想就是把同步处理和异步处理分层，而 半同步/半反应堆（Half-Sync/Half-Reactor） 则是在基础上引入了同步线程池来处理任务

## 线程池
空间换时间,浪费服务器的硬件资源,换取运行效率.
池是一组资源的集合,这组资源在服务器启动之初就被完全创建好并初始化,这称为静态资源.
当服务器进入正式运行阶段,开始处理客户请求的时候,如果它需要相关的资源,可以直接从池中获取,无需动态分配.
当服务器处理完一个客户连接后,可以把相关的资源放回池中,无需执行系统调用释放资源.

## I/O 模式
1. 阻塞 I/O（Blocking I/O）
在阻塞 I/O 模型中，用户进程调用 recvfrom() 或 read() 之类的系统调用后，会一直阻塞，直到数据准备好并被复制到用户缓冲区。当操作完成后，进程才会被唤醒，继续执行后续操作。
优点：编程简单，适用于同步场景。
缺点：进程在等待数据期间无法执行其他任务，CPU 资源浪费较大。
适用场景：简单的网络通信，如小型 Web 服务器。

2. 非阻塞 I/O（Non-blocking I/O）
在非阻塞 I/O 模型中，进程调用 recvfrom() 时，如果数据尚未准备好，系统调用会立即返回一个错误（如 EWOULDBLOCK），而不会阻塞进程。应用程序通常使用轮询（不断调用 recvfrom()）来检查数据是否就绪。
优点：进程不会被阻塞，可以执行其他任务，提高 CPU 利用率。
缺点：需要不断轮询，占用 CPU 资源，效率不高。
适用场景：适用于对实时性要求较高的应用，如高频交易系统。

3. I/O 多路复用（I/O Multiplexing）
I/O 多路复用 通过 select(), poll() 或 epoll() 让进程同时监听多个 I/O 事件，而不必为每个 I/O 任务创建一个线程或进程。进程可以在事件就绪时进行 I/O 操作，而不是一直轮询。
优点：
适用于多个 I/O 任务的场景（如高并发服务器）。
epoll（Linux 特有）相较于 select 和 poll 具有更好的性能。
缺点：
select() 和 poll() 的效率在大量连接时较低。
epoll 仅适用于 Linux，跨平台性不强。
适用场景：高并发服务器，如 Nginx、Redis。

4. 信号驱动 I/O（Signal-driven I/O）

5. 异步 I/O（Asynchronous I/O, AIO）

